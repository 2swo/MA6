// 보드 값 =[[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]]
// moves 값 =[1,5,3,5,1,2,1,4] 결과 = 4
function solution(board, moves) {
  board = [
    [0, 0, 0, 0, 0],
    [0, 0, 1, 0, 3],
    [0, 2, 5, 0, 1],
    [4, 2, 4, 4, 2],
    [3, 5, 1, 3, 1],
  ];
  moves = [1, 5, 3, 5, 1, 2, 1, 4];
  var count = 0;
  var stack = [];
  for (var i = 0; i < moves.length; i++) {
    // i의 값을 뽑기를 시도한 행의 번호만큼의 값이 될 때까지 for문을 돌린다
    var now = moves[i] - 1; // 현재의 뽑기를 시도한 행의 값에 -1을 해준다
    for (var j = 0; j < board.length; j++) {
      // j의 값을 뽑기판 번호만큼 될 때 까지 for문을 돌린다
      if (board[j][now] != 0) {
        // 뽑기판 번호가 0이 아니면
        if (stack[stack.length - 1] === board[j][now]) {
          // 직전에 들어온 뽑기와 이번에 뽑은 뽑기의 값을 비교하여 맞다면
          stack.pop(); // 없앤다
          count += 2; // 2개를 지웠으니 2개를 카운트 업 해준다
        } else {
          stack.push(board[j][now]); // 같지 않다면 j의 값 (뽑기판 번호) 까지 돌린다
        }
        board[j][now] = 0; // 뽑기판의 번호가 0이면
        break; // 멈춘다
      }
    }
  }
  return count; // 카운트된 숫자(같은 것을 뽑았을 때 없애고 다른 것만이 나왔을때 카운트한 값)
}

//////////////////////////////////////////////졸라 어렵네
