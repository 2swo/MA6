function solution(n, arr1, arr2) {
  // 2진법으로 변환한 arr1 - ['01001', '10100', '11100', '10010', '01011']
  // 2진법으로 변환한 arr2 - ['11110', '00001', '10101', '10001', '11100']
  const secretMap = arr1.map((m, idx) => (m | arr2[idx]).toString(2));
  // OR 비트연산 적용 후   - ['11111', '10101', '11101', '10011', '11111']
  // map()으로 순환하여 정규식을 사용하여 1은 #으로 0은 ' '공백으로 변환 후 반환
  // toString 함수로 변환한 2진법 변환 중 앞에 0이 사라지는 경우가 존재함.
  return secretMap.map(
    (m) => m.padStart(n, "0").replace(/1/g, "#").replace(/0/g, " ")
    // padStart()를 이용하여 n의 수 만큼 앞에 0을 채워준다.
  );
}

// arr1과 arr2 중 하나라도 벽이라면 그것은 벽이다
// arr1과 arr2 중 둘 다 벽이거나 둘 다 길이면 그것은 벽, 길이다.
// or 연산자 사용하면 될듯
